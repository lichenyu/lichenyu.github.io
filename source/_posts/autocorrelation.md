title: 自相关函数相关内容
date: 2019/04/11
categories:
- Data Analysis
tags:
- Algorithm
---


以下根据统计定义，暂不考虑概率论定义。
$A_{t} = A_{1}, A_{2}, ..., A_{n}$表示一组数据（时间序列）。


## 均值 ##

平均数

{% math %}
\begin{aligned}
\mu = E(A_{t}) = \frac{\sum_{i=1}^{n}A_{i}}{n}
\end{aligned}
{% endmath %}


## 方差 ##

方差用来衡量数据的离散程度。
每个数据点与数据均值**差方**的平均数。

{% math %}
\begin{aligned}
\sigma^{2} = var(A_{t}) = E(A_{t} - \mu)^{2} = \frac{\sum_{i=1}^{n}(A_{i} - \mu )^{2}}{n}
\end{aligned}
{% endmath %}

**方差中除以n和除以n-1的区别**
我们通常所说的方差有两种，一种是样本方差，一种是总体方差。
当求总体方差的时候，分母是$n$；当求样本方差的时候，分母是$n-1$。
在数理统计中，一般所求的都是样本方差，这就需要构造一个统计量*样本方差*（注意这是一个随机变量），需要使构造的统计量的期望与总体方差相等，这样才能使统计量具有无偏性。
- 求总体方差的情形：比如，一个班50个人，每个人的数学成绩都知道，让你求平均数和方差。这时所说的方差就是总体方差了，这里不存在任何采样的问题，所以没有随机变量，也没有期望这个概念。
- 求样本方差的情形：比如，有一亿个数据，我们想知道这个总体的方差是多少。去统计这一亿个数据是非常困难的，所以我们希望通过对总体抽取一万个样本，通过对样本方差的计算来估计出总体方差。这就需要我们来构造一个合适的统计量（样本方差）来估计总体方差。


## 标准差 ##

方差开方，量纲与数据一致。
各数据点到均值的距离之平均。

{% math %}
\begin{aligned}
\sigma = \sqrt{\sigma^{2}}
\end{aligned}
{% endmath %}


## 协方差 ##

协方差用来衡量两组数据（在各个相应时刻）“偏离各自均值”的一致程度。
如果两组数据的变化趋势一致，也就是说如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两组数据之间的协方差就是正值（变化趋势相同）。
如果两组数据的变化趋势相反，即其中一个大于自身的期望值，另外一个却小于自身的期望值，那么两组数据之间的协方差就是负值（变化趋势相反）。
如果两组数据是统计独立的，那么二者之间的协方差就是0。但是反过来并不成立，即如果两组的协方差为0，二者并不一定是统计独立的（只能看出二者不是线性关系）。

{% math %}
\begin{aligned}
r = cov(A_{t}, B_{t}) = E((A_{t} - \mu)(B_{t} - \nu)) = \frac{\sum_{i=1}^{n}(A_{i} - \mu )(B_{i} - \nu)}{n}
\end{aligned}
{% endmath %}

**协方差中除以n和除以n-1的区别，与方差相同**

上述为二维数据（两组）。若数据为多维，则需要计算多个协方差。使用矩阵来组织这些协方差，给出协方差矩阵的定义$c_{i,j} = cov(Dom_{i}, Dom_{j})$。


## 相关系数 ##

*皮尔逊相关系数*
将协方差去除量纲影响，进行标准化。

{% math %}
\begin{aligned}
\rho = \frac{cov(A_{t}, B_{t})}{\sigma_{A} \sigma_{B}}
\end{aligned}
{% endmath %}

相关系数取值$[-1, 1]$，绝对值越大，相关性越强。


## 自协方差 ##

数据与其经过时间平移的数据之间的协方差。
衡量数据在两个不同时期之间的相关程度。

{% math %}
\begin{aligned}
&r_{k} = cov(A_{t}, A_{t + k}) = E((A_{t} - \mu)(A_{t + k} - \mu)) = \frac{\sum_{i=1}^{n - k}(A_{i} - \mu )(A_{i + k} - \mu)}{n - k}\\
&k = 0,1, ..., n-1
\end{aligned}
{% endmath %}

平移后，参与自协方差计算的数据长度为$n-k$。
将$k$视为变量，则$r_{k}， k = 0,1, ..., n-1$为**自协方差函数**。
当$k=0$时，$r_{0} = \sigma^{2}$。


## 自相关系数 ##

将自协方差去除量纲影响，进行标准化。

{% math %}
\begin{aligned}
&\rho_{k} = \frac{cov(A_{t}, A_{t + k})}{\sigma^{2}} = \frac{r_{k}}{r_{0}}\\
&k = 0,1, ..., n-1
\end{aligned}
{% endmath %}

将$k$视为变量，则$\rho_{k}， k = 0,1, ..., n-1$为**自相关函数**。

**MORE**：

在信号处理中，往往提前对信号进行无偏（均值为0）归一化（标准差为1）处理，此时计算**自协方差系数**不需要减去均值。
这样好处是可以通过**点积**计算离散序列的自协方差、自相关系数（见下文）。

对于离散信号，
{% math %}
\begin{aligned}
r_{k} = \frac{\sum_{i=0}^{n-k-1} y(i)\bar{y}(i+k)}{n-k}, k = 0,1, ..., n-1
\end{aligned}
{% endmath %}
注意，这里分子上的运算其实是**向量点乘（内积）**运算。
下标为了对应程序代码，调整为$[0, n-k-1]$。

**MORE**：

**相关函数与卷积**

上文离散信号为例，其自协方差**函数**结果，其实是一个**卷积**计算与**$k$所决定的权重**乘积的结果。（卷积算出来的是一个**序列**，而非一个值。乘以权重后，对应不同$k$值时，数据的自协方差，即自协方差函数值）

{% math %}
\begin{aligned}
&r_{k} = \frac{\sum_{i=0}^{n-k-1}y(i)\bar{y}(i+k)}{n-k} \\
&\sum_{i=0}^{n-k-1} y(i)\bar{y}(i+k) = y(k) * \bar{y}(-k） \\
&k = 0,1, ..., n-1
\end{aligned}
{% endmath %}
$k$是自变量，表示延迟。$n$为序列长度。
$*$表示卷积，${f}(-k）$表示翻转$f(k)$。根据卷积含义（先翻转、再平移），可得上式。

而对应每个$k$值，求算自协方差$r_{k}$时，做的**向量点乘**（向量对应项相乘，再全部相加，得到一个数），其实就是在计算**卷积结果中的一项**。

代码示例
```python
# -*- coding: UTF-8 -*-
import numpy as np

if __name__ == '__main__':
    # 本示例数据未做标准化

    # f(t)
    x1 = [1, 7, 5, 1, 7, 5]
    n = len(x1)

    # k = 0, 1, 2, ..., n - 1
    r = [0] * n
    # acovf
    for k in range(0, n):
        x1_1 = x1[:n - k]
        x1_2 = x1[k:]
        sum = 0
        for i in range(0, len(x1_1)):
            sum = sum + x1_1[i] * x1_2[i]
        r[k] = sum / (n - k)
    print(r)

    # f(-t)
    x2 = [5, 7, 1, 5, 7, 1]
    # convolution
    y = np.convolve(x1, x2)
    # weight: n - k
    xi = range(1, n + 1)
    d = xi + xi[:-1][::-1]
    # acovf
    r = (y / d)[n - 1:]
    print(r)

```

对求得的**自协方差函数**值，全体除以$r_{0}$，即可得**自相关函数**。


此外，
- 周期函数的自相关函数是具有与原函数相同周期的函数。
- {% post_link fft_convolution 使用FFT加速卷积求算 %}
